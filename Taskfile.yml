# Task 3.43.3 YAML Parsing Known Issues:
#
# 1. DO NOT use "deps" as a task name (conflicts with Task's internal keyword)
#    - Use "modt" or another name for dependency management tasks
#
# 2. DO NOT use the --checksum flag (not supported in this version)
#    - Example that fails: echo "$(task --checksum go.mod)"
#
# 3. AVOID complex shell substitutions in commands
#    - Example that fails: echo "Build successful: $(pwd)/{{.BINARY_NAME}}"
#    - Instead use: echo "Build successful: {{.BINARY_NAME}}"
#
# 4. LIMIT nesting in multi-line shell scripts
#    - Deeply nested conditional blocks can cause parsing issues
#
# 5. BE CAREFUL with status fields containing shell commands
#    - The status field under tasks can cause parsing errors with complex commands
version: "3"

vars:
  SERVICE_NAME: hello-tool-base
  BINARY_NAME: "{{.SERVICE_NAME}}"
  MODULE_PATH: github.com/dkoosis/hello-tool-base
  CMD_PATH: ./cmd/{{.SERVICE_NAME}}
  SCRIPT_DIR: ./scripts

  VERSION:
    sh: git describe --tags --always --dirty --match=v* 2>/dev/null || echo "dev"
  COMMIT_HASH:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
  BUILD_DATE:
    sh: date -u '+%Y-%m-%dT%H:%M:%SZ'

  LDFLAGS: "-s -w -X {{.MODULE_PATH}}/internal/buildinfo.Version={{.VERSION}} -X {{.MODULE_PATH}}/internal/buildinfo.CommitHash={{.COMMIT_HASH}} -X {{.MODULE_PATH}}/internal/buildinfo.BuildDate={{.BUILD_DATE}}"

  GOLANGCILINT_VERSION: latest
  GOTESTSUM_VERSION: latest
  WARN_LINES: 350
  FAIL_LINES: 1500

  PROJECT_ID:
    sh: gcloud config get-value project 2>/dev/null || echo ""
  GCP_REGION: us-central1
  ARTIFACT_REGISTRY_REPO: my-go-apps
  CLOUDBUILD_CONFIG_PATH: ./build/cloudbuild/cloudbuild.yaml
  GCLOUD_BUILD_SUBSTITUTIONS: "_SERVICE_NAME={{.SERVICE_NAME}},_REGION={{.GCP_REGION}},_ARTIFACT_REGISTRY_REPO={{.ARTIFACT_REGISTRY_REPO}},_MODULE_PATH={{.MODULE_PATH}},_MAKEFILE_VERSION={{.VERSION}},_MAKEFILE_COMMIT={{.COMMIT_HASH}}"

env:
  CGO_ENABLED: 0

output: prefixed

tasks:
  default:
    cmds:
      - task all

  all:
    cmds:
      - task check-gomod
      - task tree
      - task modt
      - task fmt
      - task lint
      - task lint-yaml
      - task check-line-length
      - task test
      - task build
      - echo "All tasks completed successfully"

  build:
    sources:
      - "{{.CMD_PATH}}/**/*.go"
      - "./internal/**/*.go"
    generates:
      - "{{.BINARY_NAME}}"
    cmds:
      - GOOS=linux GOARCH=amd64 go build -ldflags="{{.LDFLAGS}}" -o {{.BINARY_NAME}} {{.CMD_PATH}}

  clean:
    cmds:
      - rm -f {{.BINARY_NAME}} coverage.out
      - go clean -cache -testcache

  modt:
    sources:
      - go.mod
      - go.sum
    cmds:
      - go mod tidy -v
      - go mod download

  tree:
    cmds:
      - mkdir -p ./docs
      - |
        if ! command -v tree > /dev/null; then
          exit 0
        else
          tree -F -I 'vendor|.git|.idea*|*.DS_Store|{{.BINARY_NAME}}|coverage.out' --dirsfirst > ./docs/project_directory_tree.txt || exit 1
        fi
    generates:
      - ./docs/project_directory_tree.txt

  test:
    sources:
      - "{{.CMD_PATH}}/**/*.go"
      - "./internal/**/*.go"
    generates:
      - coverage.out
    cmds:
      - task install-tools
      - gotestsum --format testdox -- -race -coverprofile=coverage.out -covermode=atomic ./...

  test-debug:
    env:
      LOG_LEVEL: debug
    cmds:
      - go test -v -race -count=1 -coverprofile=coverage.out ./...

  fmt:
    sources:
      - "{{.CMD_PATH}}/**/*.go"
      - "./internal/**/*.go"
    cmds:
      - task install-tools
      - golangci-lint fmt ./...
      - go mod tidy -v

  lint:
    sources:
      - "{{.CMD_PATH}}/**/*.go"
      - "./internal/**/*.go"
    cmds:
      - task install-tools
      - golangci-lint run ./...

  lint-yaml:
    cmds:
      - |
        if ! command -v yamllint >/dev/null 2>&1; then
          if command -v pip >/dev/null 2>&1 || command -v pip3 >/dev/null 2>&1; then
            PIP_CMD=$(command -v pip || command -v pip3)
            $PIP_CMD install --user yamllint || exit 1
          else
            exit 0
          fi
        fi
        YAML_FILES=$(find . -type f \( -name "*.yaml" -o -name "*.yml" \) -not -path "./vendor/*" -not -path "./.git/*")
        if [ -n "$YAML_FILES" ]; then
          yamllint $YAML_FILES
          EXIT_CODE=$?
          if [ $EXIT_CODE -gt 1 ]; then
            exit $EXIT_CODE
          fi
        fi

  check-gomod:
    sources:
      - go.mod
    cmds:
      - "{{.SCRIPT_DIR}}/check_go_mod_path.sh {{.MODULE_PATH}}"

  check-line-length:
    sources:
      - "{{.CMD_PATH}}/**/*.go"
      - "./internal/**/*.go"
    cmds:
      - '{{.SCRIPT_DIR}}/check_file_length.sh {{.WARN_LINES}} {{.FAIL_LINES}} $(find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*") || true'

  check-vulns:
    cmds:
      - |
        if ! command -v govulncheck >/dev/null 2>&1; then
          go install golang.org/x/vuln/cmd/govulncheck@latest
        fi
        govulncheck ./...

  install-tools:
    cmds:
      - |
        if ! command -v golangci-lint >/dev/null 2>&1; then
          echo "Installing golangci-lint@{{.GOLANGCILINT_VERSION}}..."
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@{{.GOLANGCILINT_VERSION}}
        fi
      - |
        if ! command -v gotestsum >/dev/null 2>&1; then
          echo "Installing gotestsum@{{.GOTESTSUM_VERSION}}..."
          go install gotest.tools/gotestsum@{{.GOTESTSUM_VERSION}}
        fi

  _check-gcp-project:
    interactive: true
    cmds:
      - |
        if [ -z "{{.PROJECT_ID}}" ]; then
          echo "ERROR: Google Cloud Project ID not found." >&2
          exit 1
        fi

  deploy:
    cmds:
      - task all
      - task check-vulns
      - task _check-gcp-project
      - |
        CONFIG_FILE_TO_USE=""
        if [ -f "{{.CLOUDBUILD_CONFIG_PATH}}" ]; then
            CONFIG_FILE_TO_USE="{{.CLOUDBUILD_CONFIG_PATH}}"
        elif [ -f "./cloudbuild.yaml" ]; then
            CONFIG_FILE_TO_USE="./cloudbuild.yaml"
        else
            echo "ERROR: Cloud Build config file not found" >&2
            exit 1
        fi
        gcloud builds submit . \
          --config="$CONFIG_FILE_TO_USE" \
          --project="{{.PROJECT_ID}}" \
          --substitutions="{{.GCLOUD_BUILD_SUBSTITUTIONS}}"
      - task health-check

  health-check:
    vars:
      URL: "{{.HEALTH_CHECK_URL}}"
      E_VERSION: "{{.EXPECTED_VERSION | default .VERSION}}"
      E_COMMIT: "{{.EXPECTED_COMMIT | default .COMMIT_HASH}}"
    cmds:
      - |
        set -e
        if [ -z "{{.URL}}" ]; then
          SERVICE_URL_HC=$(gcloud run services describe {{.SERVICE_NAME}} --platform=managed --region={{.GCP_REGION}} --project={{.PROJECT_ID}} --format="value(status.url)" 2>/dev/null)
          if [ -z "$SERVICE_URL_HC" ]; then
            echo "ERROR: Could not retrieve service URL" >&2
            exit 1
          fi
          URL_TO_CHECK="$SERVICE_URL_HC/health"
        else
          URL_TO_CHECK="{{.URL}}"
        fi

        SUCCESS=false
        for i in $(seq 1 5); do
          RESPONSE=$(curl -f -s -S -L --connect-timeout 5 --max-time 10 -w "\nHTTP_CODE:%{http_code}" "$URL_TO_CHECK" || echo "ERROR\nHTTP_CODE:0")
          BODY=$(echo "$RESPONSE" | sed '$d')
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" -eq 200 ]; then
            if command -v jq >/dev/null 2>&1; then
                RESPONSE_VERSION=$(echo "$BODY" | jq -r .version 2>/dev/null)
                RESPONSE_COMMIT=$(echo "$BODY" | jq -r .commit 2>/dev/null)
                if [ "$RESPONSE_VERSION" = "{{.E_VERSION}}" ] && [ "$RESPONSE_COMMIT" = "{{.E_COMMIT}}" ]; then
                    SUCCESS=true; break
                fi
            else
                SUCCESS=true; break
            fi
          fi
          if [ $i -lt 5 ]; then sleep 10; fi
        done
        if [ "$SUCCESS" = "false" ]; then
            echo "ERROR: Health check FAILED" >&2
            exit 1
        fi
