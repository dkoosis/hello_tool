# File: Taskfile.yml
version: "3"

vars:
  SERVICE_NAME: hello-tool-base
  BINARY_NAME: "{{.SERVICE_NAME}}"
  BINARY_NAME_LINUX: "{{.BINARY_NAME}}-linux-amd64"
  MODULE_PATH: github.com/dkoosis/hello-tool-base
  CMD_PATH: ./cmd/{{.SERVICE_NAME}}
  SCRIPT_DIR: ./scripts

  VERSION_FROM_GIT:
    sh: git describe --tags --always --dirty --match=v* 2>/dev/null || echo "dev-from-git"
  COMMIT_HASH_FROM_GIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown-from-git"
  BUILD_DATE:
    sh: date -u '+%Y-%m-%dT%H:%M:%SZ'

  LDFLAGS_COMMON: "-s -w -X {{.MODULE_PATH}}/internal/buildinfo.Version={{.VERSION_FROM_GIT}} -X {{.MODULE_PATH}}/internal/buildinfo.CommitHash={{.COMMIT_HASH_FROM_GIT}} -X {{.MODULE_PATH}}/internal/buildinfo.BuildDate={{.BUILD_DATE}}"

  GOLANGCILINT_VERSION: latest
  GOTESTSUM_VERSION: latest

  WARN_LINES: 350
  FAIL_LINES: 1500

  PROJECT_ID:
    sh: gcloud config get-value project 2>/dev/null || echo ""
  GCP_REGION: us-central1
  ARTIFACT_REGISTRY_REPO: my-go-apps
  CLOUDBUILD_CONFIG_PATH: ./build/cloudbuild/cloudbuild.yaml

  GCLOUD_BUILD_SUBSTITUTIONS: "_SERVICE_NAME={{.SERVICE_NAME}},_REGION={{.GCP_REGION}},_ARTIFACT_REGISTRY_REPO={{.ARTIFACT_REGISTRY_REPO}},_MODULE_PATH={{.MODULE_PATH}},_MAKEFILE_VERSION={{.VERSION_FROM_GIT}},_MAKEFILE_COMMIT={{.COMMIT_HASH_FROM_GIT}}"

  NATIVE_GOOS:
    sh: go env GOOS
  NATIVE_GOARCH:
    sh: go env GOARCH

  # Message Prefixes (kept for structure, but the `task: echo` line is what we are minimizing)
  MSG_STEP_MAJOR_START: "===== Starting: "
  MSG_STEP_MAJOR_END: "===== Completed: "
  MSG_STEP_START: "--- Starting: "
  MSG_STEP_END: "--- Completed: "
  MSG_INFO: "  INFO:"
  MSG_OK: "  OK:"
  MSG_FAIL: "  FAIL:"
  MSG_WARN: "  WARN:"
  MSG_CMD: "  CMD:" # For echoing the command string itself

env:
  CGO_ENABLED: 0

output: prefixed

tasks:
  default:
    desc: "Default task: runs all local checks, tests, and builds the native binary."
    cmds:
      - task: all

  all:
    desc: "Runs all checks, tests, and builds the native binary locally."
    cmds:
      - cmd: echo "{{.MSG_STEP_MAJOR_START}}Local Build & Check Process ({{.SERVICE_NAME}}) ====="
        silent: true
      - task: check-gomod
      - task: modt
      - task: fmt
      - task: lint
      - task: check-line-length
      - task: test
      - task: build-native
      - cmd: echo "{{.MSG_STEP_MAJOR_END}}Local Build & Check Process. Native binary '{{.BINARY_NAME}}' is ready. ====="
        silent: true

  build-linux:
    desc: "Builds the Go binary for Linux AMD64 (for Docker/Cloud Run)."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Building for Linux AMD64 (v{{.VERSION_FROM_GIT}}, c{{.COMMIT_HASH_FROM_GIT}})..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} GOOS=linux GOARCH=amd64 go build -ldflags=\"{{.LDFLAGS_COMMON}}\" -o {{.BINARY_NAME_LINUX}} {{.CMD_PATH}}"
        silent: true # Echo the command string, but Task itself is silent for this echo
      - cmd: GOOS=linux GOARCH=amd64 go build -ldflags="{{.LDFLAGS_COMMON}}" -o {{.BINARY_NAME_LINUX}} {{.CMD_PATH}}
      - cmd: echo "{{.MSG_OK}} Linux AMD64 binary '{{.BINARY_NAME_LINUX}}' built."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Building for Linux AMD64."
        silent: true

  build-native:
    desc: "Builds the Go binary for the current native OS/architecture."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Building for native OS/Arch ({{.NATIVE_GOOS}}-{{.NATIVE_GOARCH}}, v{{.VERSION_FROM_GIT}}, c{{.COMMIT_HASH_FROM_GIT}})..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} go build -ldflags=\"{{.LDFLAGS_COMMON}}\" -o {{.BINARY_NAME}} {{.CMD_PATH}}"
        silent: true
      - cmd: go build -ldflags="{{.LDFLAGS_COMMON}}" -o {{.BINARY_NAME}} {{.CMD_PATH}}
      - cmd: echo "{{.MSG_OK}} Native binary '{{.BINARY_NAME}}' built."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Building for native OS/Arch."
        silent: true

  run:
    desc: "Builds (native) and runs the Go binary locally."
    deps: [build-native]
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Running native binary '{{.BINARY_NAME}}'..."
        silent: true
      - cmd: ./{{.BINARY_NAME}}
        env:
          LOG_LEVEL: "debug"
      - cmd: echo "{{.MSG_STEP_END}}Running native binary." # This might only show if the above command exits
        silent: true

  clean:
    desc: "Removes build artifacts and clears Go caches."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Cleaning build artifacts and caches..."
        silent: true
      - cmd: rm -f {{.BINARY_NAME}} {{.BINARY_NAME_LINUX}} coverage.out
      - cmd: go clean -cache -testcache
      - cmd: echo "{{.MSG_OK}} Cleaned."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Cleaning."
        silent: true

  modt:
    desc: "Tidies and downloads Go modules."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Synchronizing Go modules..."
        silent: true
      - cmd: echo "{{.MSG_INFO}} Running go mod tidy -v"
        silent: true
      - cmd: go mod tidy -v
      - cmd: echo "{{.MSG_INFO}} Running go mod download"
        silent: true
      - cmd: go mod download
      - cmd: echo "{{.MSG_OK}} Modules synchronized."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Synchronizing Go modules."
        silent: true

  test:
    desc: "Runs Go tests with race detector and coverage."
    cmds:
      - task: install-tools
      - cmd: echo "{{.MSG_STEP_START}}Running tests..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} gotestsum --format testdox -- -race -coverprofile=coverage.out -covermode=atomic ./..."
        silent: true
      - cmd: gotestsum --format testdox -- -race -coverprofile=coverage.out -covermode=atomic ./...
      - cmd: echo "{{.MSG_OK}} Tests completed."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Running tests."
        silent: true

  test-debug:
    desc: "Runs Go tests verbosely with race detector (sets LOG_LEVEL=debug)."
    env:
      LOG_LEVEL: debug
    cmds:
      - task: install-tools
      - cmd: echo "{{.MSG_STEP_START}}Running tests (verbose debug mode)..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} go test -v -race -count=1 -coverprofile=coverage.out ./..."
        silent: true
      - cmd: go test -v -race -count=1 -coverprofile=coverage.out ./...
      - cmd: echo "{{.MSG_OK}} Debug tests completed."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Running tests (verbose debug mode)."
        silent: true

  fmt:
    desc: "Formats Go code using golangci-lint and tidies modules."
    cmds:
      - task: install-tools
      - cmd: echo "{{.MSG_STEP_START}}Formatting Go code..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} golangci-lint fmt ./..."
        silent: true
      - cmd: golangci-lint fmt ./...
      - cmd: echo "{{.MSG_INFO}} Tidying go.mod after format..."
        silent: true
      - cmd: go mod tidy -v
      - cmd: echo "{{.MSG_OK}} Code formatting complete."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Formatting Go code."
        silent: true

  lint:
    desc: "Lints Go code using golangci-lint."
    cmds:
      - task: install-tools
      - cmd: echo "{{.MSG_STEP_START}}Running linters..."
        silent: true
      - cmd: echo "{{.MSG_CMD}} golangci-lint run ./..."
        silent: true
      - cmd: golangci-lint run ./... # Output of lint will show issues
      - cmd: echo "{{.MSG_OK}} Linting complete (check output for issues)."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Running linters."
        silent: true

  check-gomod:
    desc: "Checks if the Go module path in go.mod matches the expected MODULE_PATH."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Checking go.mod module path (expecting {{.MODULE_PATH}})..."
        silent: true
      - cmd: "{{.SCRIPT_DIR}}/check_go_mod_path.sh {{.MODULE_PATH}}" # Script provides its own OK/FAIL
      - cmd: echo "{{.MSG_STEP_END}}Checking go.mod module path."
        silent: true

  check-line-length:
    desc: "Checks for Go files exceeding specified line lengths."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Checking line lengths (Warn {{.WARN_LINES}}, Fail {{.FAIL_LINES}})..."
        silent: true
      - cmd: '{{.SCRIPT_DIR}}/check_file_length.sh {{.WARN_LINES}} {{.FAIL_LINES}} $(find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*") || true'
      - cmd: echo "{{.MSG_OK}} Line length check complete (check output for warnings/errors)." # Script provides summary
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Checking line lengths."
        silent: true

  check-vulns:
    desc: "Checks for vulnerabilities in Go dependencies using govulncheck."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Checking for vulnerabilities..."
        silent: true
      - |
        if ! command -v govulncheck >/dev/null 2>&1; then
          echo "{{.MSG_INFO}} govulncheck not found, attempting to install..."
          go install golang.org/x/vuln/cmd/govulncheck@latest
        fi
        echo "{{.MSG_INFO}} Running govulncheck..."
        govulncheck ./... # Actual output from govulncheck is important
        echo "{{.MSG_OK}} Vulnerability check completed."
      - cmd: echo "{{.MSG_STEP_END}}Checking for vulnerabilities."
        silent: true

  install-tools:
    desc: "Installs necessary Go development tools if not already present or if version differs."
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Checking/installing Go tools on {{.NATIVE_GOOS}}-{{.NATIVE_GOARCH}}..."
        silent: true
      - | # This block already has good conditional echoing, so we'll keep its style
        echo "{{.MSG_INFO}} Checking golangci-lint (Target: {{.GOLANGCILINT_VERSION}})..."
        INSTALLED_GCL_VERSION=$(golangci-lint --version 2>/dev/null | awk '{print $4}')
        TARGET_GCL_VERSION="{{.GOLANGCILINT_VERSION}}"
        NEEDS_GCL_INSTALL=false
        if ! command -v golangci-lint >/dev/null 2>&1; then
          NEEDS_GCL_INSTALL=true
          echo "{{.MSG_WARN}} golangci-lint not found."
        elif [ "$TARGET_GCL_VERSION" != "latest" ] && [ "$INSTALLED_GCL_VERSION" != "$TARGET_GCL_VERSION" ]; then
          NEEDS_GCL_INSTALL=true
          echo "{{.MSG_WARN}} golangci-lint version mismatch. Found: $INSTALLED_GCL_VERSION, Target: $TARGET_GCL_VERSION."
        elif [ "$TARGET_GCL_VERSION" = "latest" ]; then
          echo "{{.MSG_INFO}} golangci-lint found ($INSTALLED_GCL_VERSION). Target is 'latest', not forcing update."
        else
          echo "{{.MSG_INFO}} golangci-lint is already installed and at the target version ($INSTALLED_GCL_VERSION)."
        fi

        if [ "$NEEDS_GCL_INSTALL" = true ]; then
          echo "{{.MSG_INFO}} Installing/Updating golangci-lint@$TARGET_GCL_VERSION..."
          GOBIN=$(go env GOBIN Default:$(go env GOPATH)/bin) go install github.com/golangci/golangci-lint/cmd/golangci-lint@$TARGET_GCL_VERSION && \
          echo "{{.MSG_OK}} golangci-lint installed/updated: $(golangci-lint --version | awk '{print $4}')" || \
          (echo "{{.MSG_FAIL}} golangci-lint installation/update failed." && exit 1)
        fi
      - | # Similar for gotestsum
        echo "{{.MSG_INFO}} Checking gotestsum (Target: {{.GOTESTSUM_VERSION}})..."
        INSTALLED_GTS_VERSION=$(gotestsum --version 2>/dev/null | awk -F'[ ,]+' '{print $3}')
        TARGET_GTS_VERSION="{{.GOTESTSUM_VERSION}}"
        NEEDS_GTS_INSTALL=false
        if ! command -v gotestsum >/dev/null 2>&1; then
          NEEDS_GTS_INSTALL=true
          echo "{{.MSG_WARN}} gotestsum not found."
        elif [ "$TARGET_GTS_VERSION" != "latest" ] && [ "$INSTALLED_GTS_VERSION" != "$TARGET_GTS_VERSION" ]; then
          NEEDS_GTS_INSTALL=true
          echo "{{.MSG_WARN}} gotestsum version mismatch. Found: $INSTALLED_GTS_VERSION, Target: $TARGET_GTS_VERSION."
        elif [ "$TARGET_GTS_VERSION" = "latest" ]; then
          echo "{{.MSG_INFO}} gotestsum found ($INSTALLED_GTS_VERSION). Target is 'latest', not forcing update."
        else
          echo "{{.MSG_INFO}} gotestsum is already installed and at the target version ($INSTALLED_GTS_VERSION)."
        fi

        if [ "$NEEDS_GTS_INSTALL" = true ]; then
          echo "{{.MSG_INFO}} Installing/Updating gotestsum@$TARGET_GTS_VERSION..."
          GOBIN=$(go env GOBIN Default:$(go env GOPATH)/bin) go install gotest.tools/gotestsum@$TARGET_GTS_VERSION && \
          echo "{{.MSG_OK}} gotestsum installed/updated: $(gotestsum --version | awk -F'[ ,]+' '{print $3}')" || \
          (echo "{{.MSG_FAIL}} gotestsum installation/update failed." && exit 1)
        fi
      - cmd: echo "{{.MSG_OK}} Go tools check/installation complete."
        silent: true
      - cmd: echo "{{.MSG_STEP_END}}Checking/installing Go tools."
        silent: true

  _check-gcp-project:
    internal: true
    silent: true # Make this fully silent from Task's perspective
    cmds:
      - |
        PROJECT_ID_CHECK="{{.PROJECT_ID}}"
        if [ -z "$PROJECT_ID_CHECK" ]; then
          echo "FAIL: Google Cloud Project ID not found. Not set in 'gcloud config get-value project'." >&2 # No task prefix
          echo "      Please set using 'gcloud config set project YOUR_PROJECT_ID'" >&2
          exit 1
        fi
        echo "INFO: Using Google Cloud Project ID: $PROJECT_ID_CHECK" # No task prefix

  deploy:
    desc: "Runs local checks, then submits build to Google Cloud for deployment."
    cmds:
      - cmd: echo "" # Blank line for separation
        silent: true
      - cmd: echo "{{.MSG_STEP_MAJOR_START}}Full Deployment Process for {{.SERVICE_NAME}} (v{{.VERSION_FROM_GIT}}, c{{.COMMIT_HASH_FROM_GIT}}) ====="
        silent: true
      - cmd: echo "" # Blank line
        silent: true
      - task: all
      - task: check-vulns
      - task: _check-gcp-project
      - cmd: echo "" # Blank line
        silent: true
      - cmd: echo "{{.MSG_STEP_START}}Preparing Google Cloud Build submission..."
        silent: true
      - |
        set -e
        CONFIG_FILE_TO_USE=""
        if [ -f "{{.CLOUDBUILD_CONFIG_PATH}}" ]; then
            CONFIG_FILE_TO_USE="{{.CLOUDBUILD_CONFIG_PATH}}"
        elif [ -f "./cloudbuild.yaml" ]; then
            echo "{{.MSG_WARN}} Cloud Build config not found at {{.CLOUDBUILD_CONFIG_PATH}}, using ./cloudbuild.yaml"
            CONFIG_FILE_TO_USE="./cloudbuild.yaml"
        else
            echo "{{.MSG_FAIL}} Cloud Build config file not found at {{.CLOUDBUILD_CONFIG_PATH}} or ./cloudbuild.yaml"
            exit 1
        fi
        echo "{{.MSG_INFO}} Using Cloud Build config file: $CONFIG_FILE_TO_USE"
        echo "{{.MSG_INFO}} Substitutions for Cloud Build (Project: {{.PROJECT_ID}}):"
        echo "{{.MSG_INFO}}   _SERVICE_NAME={{.SERVICE_NAME}}"
        echo "{{.MSG_INFO}}   _REGION={{.GCP_REGION}}"
        echo "{{.MSG_INFO}}   _ARTIFACT_REGISTRY_REPO={{.ARTIFACT_REGISTRY_REPO}}"
        echo "{{.MSG_INFO}}   _MODULE_PATH={{.MODULE_PATH}}"
        echo "{{.MSG_INFO}}   _MAKEFILE_VERSION={{.VERSION_FROM_GIT}}"
        echo "{{.MSG_INFO}}   _MAKEFILE_COMMIT={{.COMMIT_HASH_FROM_GIT}}"
        echo "" # Blank line before command
        echo "{{.MSG_CMD}} gcloud builds submit . --config=\"$CONFIG_FILE_TO_USE\" --project=\"{{.PROJECT_ID}}\" --substitutions=\"{{.GCLOUD_BUILD_SUBSTITUTIONS}}\""
        gcloud builds submit . \
          --config="$CONFIG_FILE_TO_USE" \
          --project="{{.PROJECT_ID}}" \
          --substitutions="{{.GCLOUD_BUILD_SUBSTITUTIONS}}" # gcloud output will be prefixed by [deploy]

        BUILD_SUBMIT_STATUS=$?
        if [ $BUILD_SUBMIT_STATUS -ne 0 ]; then
            echo "{{.MSG_FAIL}} Google Cloud Build submission failed (Status: $BUILD_SUBMIT_STATUS)."
            exit $BUILD_SUBMIT_STATUS
        fi
        # gcloud submit is verbose on its own, so a simple OK might be enough
        echo "{{.MSG_OK}} Google Cloud Build submission initiated."
      - cmd: echo "{{.MSG_STEP_END}}Preparing Google Cloud Build submission."
        silent: true
      - cmd: echo "" # Blank line
        silent: true
      - task: health-check
      - cmd: echo "" # Blank line
        silent: true
      - cmd: echo "{{.MSG_STEP_MAJOR_END}}Full Deployment Process for {{.SERVICE_NAME}}. ====="
        silent: true
      - cmd: echo "" # Blank line
        silent: true

  health-check:
    desc: "Performs a health check on the deployed service. EXPECTED_VERSION and EXPECTED_COMMIT can be overridden."
    vars:
      E_VERSION: "{{.EXPECTED_VERSION | default .VERSION_FROM_GIT}}"
      E_COMMIT: "{{.EXPECTED_COMMIT | default .COMMIT_HASH_FROM_GIT}}"
      URL: "{{.HEALTH_CHECK_URL}}"
    cmds:
      - cmd: echo "{{.MSG_STEP_START}}Health Checking service '{{.SERVICE_NAME}}'..."
        silent: true
      - |
        set -e 
        URL_TO_CHECK_HC=""
        if [ -n "{{.URL}}" ]; then
          URL_TO_CHECK_HC="{{.URL}}"
          echo "{{.MSG_INFO}} Using provided HEALTH_CHECK_URL: $URL_TO_CHECK_HC"
        else
          echo "{{.MSG_INFO}} Retrieving service URL for '{{.SERVICE_NAME}}' (Region: '{{.GCP_REGION}}', Project: '{{.PROJECT_ID}}')..."
          PROJECT_ID_FOR_GCLOUD="{{.PROJECT_ID}}"
          if [ -z "$PROJECT_ID_FOR_GCLOUD" ]; then
            echo "{{.MSG_WARN}} PROJECT_ID var is empty for gcloud command, attempting to use configured default."
          fi

          SERVICE_URL_HC=$(gcloud run services describe {{.SERVICE_NAME}} --platform=managed --region={{.GCP_REGION}} --project="$PROJECT_ID_FOR_GCLOUD" --format="value(status.url)" 2>/dev/null)
          
          if [ -z "$SERVICE_URL_HC" ]; then
            echo "{{.MSG_FAIL}} Could not retrieve service URL for '{{.SERVICE_NAME}}'."
            echo "{{.MSG_INFO}}   Ensure it's deployed and name/region/project ID are correct."
            exit 1
          fi
          URL_TO_CHECK_HC="$SERVICE_URL_HC/health"
        fi

        echo "{{.MSG_INFO}} Attempting health check on: $URL_TO_CHECK_HC"
        echo "{{.MSG_INFO}} Expecting Version: '{{.E_VERSION}}', Commit: '{{.E_COMMIT}}'"

        SUCCESS=false
        MAX_RETRIES=5
        RETRY_DELAY=10 

        for i in $(seq 1 $MAX_RETRIES); do
          echo "{{.MSG_INFO}}   Health check attempt $i of $MAX_RETRIES..."
          RESPONSE=$(curl -f -s -S -L --connect-timeout 5 --max-time 10 -w "\nHTTP_CODE:%{http_code}" "$URL_TO_CHECK_HC" || echo "ERROR_CURL_FAILED\nHTTP_CODE:0")
          BODY=$(echo "$RESPONSE" | sed '$d') 
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1 | cut -d: -f2)

          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "{{.MSG_OK}}   Attempt $i SUCCEEDED with HTTP 200."
            if command -v jq >/dev/null 2>&1; then
                echo "{{.MSG_INFO}}     Verifying version and commit in response body..."
                RESPONSE_VERSION=$(echo "$BODY" | jq -r .version 2>/dev/null)
                RESPONSE_COMMIT=$(echo "$BODY" | jq -r .commit 2>/dev/null)
                echo "{{.MSG_INFO}}     Received V:'$RESPONSE_VERSION', C:'$RESPONSE_COMMIT'"
                
                if [ "$RESPONSE_VERSION" = "null" ] || [ -z "$RESPONSE_VERSION" ]; then RESPONSE_VERSION="<not_found_in_response>"; fi
                if [ "$RESPONSE_COMMIT" = "null" ] || [ -z "$RESPONSE_COMMIT" ]; then RESPONSE_COMMIT="<not_found_in_response>"; fi
                
                EXPECTED_V_HC="{{.E_VERSION}}"
                if [ "{{.E_VERSION}}" = "dev-from-git" ] && [ "$RESPONSE_VERSION" = "dev" ]; then EXPECTED_V_HC="dev"; fi
                
                EXPECTED_C_HC="{{.E_COMMIT}}"
                if [ "{{.E_COMMIT}}" = "unknown-from-git" ] && [ "$RESPONSE_COMMIT" = "unknown" ]; then EXPECTED_C_HC="unknown"; fi
                
                if [ "$RESPONSE_VERSION" = "$EXPECTED_V_HC" ] && [ "$RESPONSE_COMMIT" = "$EXPECTED_C_HC" ]; then
                    echo "{{.MSG_OK}} Health check PASSED. HTTP 200 and Version/Commit match."
                    SUCCESS=true; break
                else
                    echo "{{.MSG_WARN}}   Health check HTTP 200 OK, but version/commit mismatch or JSON parse error."
                    echo "{{.MSG_INFO}}     Expected V:'$EXPECTED_V_HC' C:'$EXPECTED_C_HC'."
                    echo "{{.MSG_INFO}}     Got      V:'$RESPONSE_VERSION' C:'$RESPONSE_COMMIT'."
                    SUCCESS=true; break 
                fi
            else
                echo "{{.MSG_OK}} Health check PASSED with HTTP 200 (jq not available for detailed version/commit check)."
                SUCCESS=true; break 
            fi
          else
            echo "{{.MSG_WARN}}   Attempt $i FAILED with HTTP Code: $HTTP_CODE."
          fi

          if [ $i -lt $MAX_RETRIES ]; then echo "{{.MSG_INFO}}   Retrying in $RETRY_DELAY seconds..."; sleep $RETRY_DELAY; fi
        done

        if [ "$SUCCESS" = "false" ]; then
            echo "{{.MSG_FAIL}} Health check FAILED for $URL_TO_CHECK_HC after $MAX_RETRIES attempts. Last HTTP Code: $HTTP_CODE."
            exit 1
        # else # Redundant OK message if loop produced one
            # echo "{{.MSG_OK}} Health check successfully completed for $URL_TO_CHECK_HC."
        fi
      - cmd: echo "{{.MSG_STEP_END}}Health Checking service '{{.SERVICE_NAME}}'."
        silent: true
